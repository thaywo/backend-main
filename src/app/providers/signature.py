from eth_account import Account
from eth_account.messages import encode_defunct
from web3 import Web3
import os
from datetime import datetime, timedelta
from typing import Tuple
from app.models.enums import SignatureType
from app.config.database_config import settings

class SignatureProvider:
    def __init__(self):
        self.private_key = settings.SIGNER_PRIVATE_KEY
        self.account = Account.from_key(self.private_key)
        self.default_expiry = timedelta(hours=1)  # signatures expire after 1 hour

    def generate_signature(
        self,
        user_address: str,
        quest_id: str,
        chain_id: int,
        contract_address: str,
        expiry: datetime = None,
        signature_type: SignatureType = SignatureType.QUEST_COMPLETION
    ) -> Tuple[str, int]:
        """
        Generates a signature for minting rewards
        
        Args:
            user_address: The address of the user completing the quest
            quest_id: Unique identifier for the quest
            chain_id: The EVM chain ID where the contract exists
            contract_address: The address of the reward contract
            expiry: Optional datetime when signature expires
            signature_type: Type of signature being generated
            
        Returns:
            Tuple of (signature, expiry_timestamp)
        """
        if not expiry:
            expiry = datetime.utcnow() + self.default_expiry
            
        expiry_timestamp = int(expiry.timestamp())
        
        # Prepare the message hash
        message_hash = Web3.solidity_keccak(
            ['address', 'string', 'uint256', 'address', 'uint256', 'uint8'],
            [
                Web3.to_checksum_address(user_address),
                quest_id,
                chain_id,
                Web3.to_checksum_address(contract_address),
                expiry_timestamp,
                signature_type.value
            ]
        )
        
        # Sign the message
        signable_message = encode_defunct(hexstr=message_hash.hex())
        signed_message = Account.sign_message(signable_message, private_key=self.private_key)
        
        return signed_message.signature.hex(), expiry_timestamp

    def verify_signature(
        self,
        user_address: str,
        quest_id: str,
        chain_id: int,
        contract_address: str,
        expiry_timestamp: int,
        signature: str,
        signature_type: SignatureType = SignatureType.QUEST_COMPLETION
    ) -> bool:
        """
        Verifies a signature was generated by this service
        """
        # Reconstruct the message hash
        message_hash = Web3.solidity_keccak(
            ['address', 'string', 'uint256', 'address', 'uint256', 'uint8'],
            [
                Web3.to_checksum_address(user_address),
                quest_id,
                chain_id,
                Web3.to_checksum_address(contract_address),
                expiry_timestamp,
                signature_type.value
            ]
        )
        
        # Recover the signer
        signable_message = encode_defunct(hexstr=message_hash.hex())
        recovered_address = Account.recover_message(
            signable_message,
            signature=signature
        )
        
        return recovered_address.lower() == self.account.address.lower()